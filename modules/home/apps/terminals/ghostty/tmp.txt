    // inputs - screen size helper
    vec2 ndc(vec2 value, float isPos) {
      // Map from pixels to NDC where Y dimension spans [-1, 1]
      return (value * 2.0 - iResolution.xy * isPos) / iResolution.y;
    }

    // Distance helper to a segment A->B
    float sdSegment(vec2 p, vec2 a, vec2 b, out float param) {
      vec2 pa = p - a;
      vec2 ba = b - a;
      float denom = max(dot(ba, ba), 1e-5);
      param = clamp(dot(pa, ba) / denom, 0.0, 1.0);
      return length(pa - ba * param);
    }

    // Randomizer
    float hash(vec3 p) {
      return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
    }

    //Tuneable Values in NDC units
    const vec4 GLITTER_COLOR = vec4(${mkRGBA_valOnly { hex = "#${colors.base06}"; alpha = 1.0; }}) / vec4(255.0, 255.0, 255.0, 1.0);
    const float GLITTER_WIDTH = 0.05;
    const float MIN_DENSITY = 0.9;
    const float MAX_DENSITY = 1.0;
    const float BRIGHTNESS = 0.75;
    const float GLITTER_PERIOD = 1.5;
    const float GLITTER_FALL_DISTANCE = 0.4;
    const float GLITTER_LIFETIME = 0.7;
    const float GLITTER_FRONT_THICKNESS = 0.1;
    const float DRAW_THRESHOLD = 1.5;
    const bool HIDE_TRAILS_ON_THE_SAME_LINE = false;

    //ShaderToy entry, pixel coords, output colors
    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
      #if !defined(WEB)
        vec4 base = texture(iChannel0, fragCoord / iResolution.xy); //Sample existing framebuffer/background
      #else
        vec4 base = vec4(0.0); //Starting color
      #endif

      //Ghostty-provided uniforms for terminal cursor state
      //Cursor position before and after movement
      vec4 curRect = iCurrentCursor;
      vec4 prvRect = iPreviousCursor;

      //Compute cursor center in pixel space before and after movement
      vec2 curCentrePx = curRect.xy + vec2(curRect.z * 0.5, -curRect.w * 0.5);
      vec2 prvCentrePx = prvRect.xy + vec2(prvRect.z * 0.5, -prvRect.w * 0.5);

      //NDC positions for all relevant points
      vec2 cur = ndc(curCentrePx, 1.0);
      vec2 prv = ndc(prvCentrePx, 1.0);
      vec2 P = ndc(fragCoord, 1.0);

      // Cursor size in NDC
      vec2 cursorSizeNdc = (iCurrentCursor.zw * 2.0) / iResolution.y;
      float cursorMaxNdc = max(cursorSizeNdc.x, cursorSizeNdc.y);

      // NDC centers already computer as `cur` and `prv`
      float travelNdc = length (cur - prv);

      //Optional same-line suppression
      bool sameLine = abs(ndc(curRect.xy, 1.0).y - ndc(prvRect.xy, 1.0).y) < 1e-6;
      bool suppressSameLine = HIDE_TRAILS_ON_THE_SAME_LINE && sameLine;

      //Gate tiny moves (suppress tiny moves)
      bool smallMove = (travelNdc <= DRAW_THRESHOLD * cursorMaxNdc);

      //Motion fade after the last cursor change
      float moveElapsed = max(iTime - iTimeCursorChange, 0.0);
      float motionPhase = clamp(moveElapsed / GLITTER_LIFETIME, 0.0, 1.0);
      float motionFade = 1.0 - smoothstep(0.0, 1.0, motionPhase);

      //Segment distance field in NDC units
      float segParam;
      float distToSeg = sdSegment(P, prv, cur, segParam);
      vec2 basePoint = mix(prv, cur, segParam);

      //Horizontal containment: constrain glitter to width around the cursor path
      // Use horizontal distance (perpendicular to path direction) to allow vertical falling
      vec2 pathVec = cur - prv;
      float pathLen = length(pathVec);
      vec2 pathDir = pathLen > 1e-5 ? pathVec / pathLen : vec2(1.0, 0.0); // handle zero-length paths
      vec2 toPoint = P - basePoint;
      float horizontalDist = abs(dot(toPoint, vec2(-pathDir.y, pathDir.x))); // perpendicular to path
      float horizontalMask = 1.0 - smoothstep(GLITTER_WIDTH * 0.2, GLITTER_WIDTH, horizontalDist);

      //Falling glitter band below the path, expressed in normalized "fall space"
      float drop = P.y - basePoint.y; //NDC delta along Y-axis (negative Y is down in NDC)
      float dropNorm = clamp(-drop / max(GLITTER_FALL_DISTANCE, 1e-4), 0.0, 1.0); // negate because Y decreases downward

      // Spatial progression: use position along the segment to create a flowing wave effect
      // Earlier parts of the segment (near prv) start animating earlier than later parts (near cur)
      float spatialDelay = segParam * 0.3; // 0.3 second delay from start to end of segment
      float localTime = iTime - spatialDelay;
      float timeline = localTime / GLITTER_PERIOD;

      //Stable per-cell phasing: grid in pixel space with fixed cell size for sparkles?
      const float cellSizePx = 2.0; //~2px cells
      vec2 sparkleCell = floor(fragCoord.xy / cellSizePx);
      float cellSeed = hash(vec3(sparkleCell, 37.0));
      float t = timeline + cellSeed;
      float cycleProg = fract(t);
      float cycleIndex = floor(t);

      //Falling band front and tail in normalized [0,1] space
      float fallHead = cycleProg;
      float fallTail = max(fallHead - GLITTER_FRONT_THICKNESS, 0.0);
      float leadingEdge = 1.0 - smoothstep(fallHead, fallHead + GLITTER_FRONT_THICKNESS, dropNorm);
      float trailingEdge = 1.0 - (1.0 - smoothstep(fallTail, fallTail + GLITTER_FRONT_THICKNESS, dropNorm));
      float fallMask = leadingEdge * trailingEdge * smoothstep(0.0, GLITTER_FRONT_THICKNESS, dropNorm);

      //Denisty responds to travel distance in NDC, clamped to [0,1]
      float travelNorm = clamp(travelNdc, 0.0, 1.0);
      float densityFactor = clamp(travelNorm * 10.0, 0.0, 1.0);
      float density = mix(MIN_DENSITY, MAX_DENSITY, densityFactor) * motionFade;

      //Spawn decision per-cell per-cycle
      float sparkle = hash(vec3(sparkleCell, cycleIndex));
      float spawn = step(1.0 - density, sparkle);

      //Fade out within a cycle so specks twinkle
      float fade = 1.0 - smoothstep(0.33, 1.0, cycleProg);

      // Progressive spawn along segment: glitter appears gradually from start to end
      // This prevents instant appearance across entire path
      float progressiveFade = smoothstep(-0.5, 1.0, localTime);

      //Travel mask in consistent units; suppress tiny moves and optional same-line
      float travelMask = (smallMove || suppressSameLine) ? 0.0 : travelNorm;

      //Final glitter mask
      float glitter = horizontalMask * fallMask * spawn * fade * progressiveFade * travelMask * motionFade;

      // Amplify glitter strength for visibility (reduce multiplicative dimming)
      float glitterStrength = sqrt(max(glitter, 0.0)) * BRIGHTNESS;

      // Additive blending: sparkles brighten the background
      vec3 glitterContribution = GLITTER_COLOR.rgb * glitterStrength * 3.0;
      fragColor = vec4(base.rgb + glitterContribution, base.a);
    }
