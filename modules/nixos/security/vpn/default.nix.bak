{ lib
, pkgs
, config
, namespace
, ...
}:
let
  inherit (lib) mkIf mkMerge mkOption mkEnableOption types;
  cfg = config.${namespace}.security.vpn;

  wgProtonConf = "wg-proton.conf";
  # ProtonVPN endpoint - you can change this to your preferred server
  protonEndpoint = "node-us-304.protonvpn.net";
in
{
  options.${namespace}.security.vpn = {
    enable = mkEnableOption "Enable VPN";
    tailscaleCompat = mkEnableOption "Activate configuration for symbiotic tailscale and wireguard VPN";
    provider = mkOption {
      type = types.str;
      default = "proton-vpn";
      description = "Select VPN provider to enable";
    };
  };

  config = mkMerge [
    (mkIf (cfg.enable && cfg.provider == "proton-vpn") {
      environment.systemPackages = [
        pkgs.protonvpn-gui
        pkgs.protonvpn-cli
      ];
    })

    (mkIf (cfg.enable && cfg.tailscaleCompat) {
      sops = {
        secrets = {
          "pvpn/priKey" = { };
          "pvpn/pubKey" = { };
        };
        templates.${wgProtonConf} = {
          path = "/etc/wireguard/${wgProtonConf}";
          owner = "root";
          group = "root";
          mode = "0400";
          content = ''
            [Interface]
            Address = 10.2.0.2/32
            Address = 2a07:b944::2:2/128
            DNS = 10.2.0.1, 2a07:b944::2:1
            PrivateKey = ${config.sops.placeholder."pvpn/priKey"}

            # Disable wg-quick's Table, to avoid it's automatic aggressive capture of all traffic. Off let's us manually control routes
            Table = off

            # Prevent pvpn's own handshake from getting trapped by policy
            # FwMark = 0xca6c

            PreUp = ${pkgs.writeShellScript "wg-proton-preup" ''
              # Pre-resolve the endpoint to avoid DNS issues at startup
              VPN_ENDPOINT_IP=$(${pkgs.dnsutils}/bin/dig +short ${protonEndpoint} A ${protonEndpoint} AAAA | head -n 1)
              if [ -z "$VPN_ENDPOINT_IP" ]; then
                echo "Failed to resolve ${protonEndpoint}"
                exit 1
              fi
              # Store the resolved IP for use in PostUp and PreDown scripts
              echo "$VPN_ENDPOINT_IP" > /run/wg-proton-endpoint-ip
            ''}

            PostUp = ${pkgs.writeShellScript "wg-proton-postup" ''
              VPN_ENDPOINT_IP=$(cat /run/wg-proton-endpoint-ip)

              # Ensure routing table exists
              grep -q "^52830\s" /etc/iproute2/rt_tables 2>/dev/null || echo "52830 wg-proton" >> /etc/iproute2/rt_tables 2>/dev/null || true

              # Add route for VPN endpoint through local gateway
              ip route add $VPN_ENDPOINT_IP via 192.168.50.1

              # Add default routes through VPN interface
              ip route add default dev wg-proton table 52830
              ip -6 route add default dev wg-proton table 52830

              #--- Local LAN(s) stay on LAN (adjust to actual subnets) ---#
              ip rule add to 192.168.50.0/24 table main priority 32500 2>/dev/null || true
              ip -6 rule add to fd33:62a6:8e4:b346::/64 table main priority 32500 2>/dev/null || true
              ip rule add to 192.168.51.0/24 table main priority 32510 2>/dev/null || true

              #--- WAN catch-alls (IPv4 + IPv6) to public vpn (guarded with fwmark so WG handshake uses WAN) ---#
              ip rule add from all lookup 52830 priority 32700 2>/dev/null || true
              ip -6 rule add from all lookup 52830 priority 32700 2>/dev/null || true
            ''}

            #--- Clean up rules on stop ---#
            PreDown = ${pkgs.writeShellScript "wg-proton-predown" ''
              VPN_ENDPOINT_IP=$(cat /run/wg-proton-endpoint-ip 2>/dev/null || ${pkgs.dnsutils}/bin/dig +short ${protonEndpoint} A ${protonEndpoint} AAAA | head -n 1)

              # Remove policy routing rules
              ip -6 rule del priority 32700 2>/dev/null || true
              ip rule del priority 32700 2>/dev/null || true
              ip rule del priority 32510 2>/dev/null || true
              ip -6 rule del priority 32500 2>/dev/null || true
              ip rule del priority 32500 2>/dev/null || true

              # Remove routes from table 52830
              ip -6 route del default dev wg-proton table 52830 2>/dev/null || true
              ip route del default dev wg-proton table 52830 2>/dev/null || true

              # Remove VPN endpoint route
              ip route del $VPN_ENDPOINT_IP 2>/dev/null || true

              # Clean up temporary file
              rm -f /run/wg-proton-endpoint-ip
            ''}

            [Peer]
            PublicKey = ${config.sops.placeholder."pvpn/pubKey"}
            Endpoint = ${protonEndpoint}:51820
            AllowedIPs = 0.0.0.0/0, ::/0
            PersistentKeepalive = 25
          '';
        };
      };

      systemd.services."wg-quick-wg-proton" = {
        after = [ "network-online.target" "nss-lookup.target" "systemd-resolved.service" ];
        wants = [ "network-online.target" "nss-lookup.target" ];
        requires = [ "systemd-resolved.service" ];
        serviceConfig = {
          # Add a retry mechanism in case DNS is still not ready
          Restart = "on-failure";
          RestartSec = "5s";
          StartLimitBurst = 3;
        };
      };


      networking.wg-quick.interfaces."wg-proton".configFile = config.sops.templates.${wgProtonConf}.path;
      networking.networkmanager.unmanaged = [ "interface-name:wg-proton" ];
      networking.resolvconf.enable = false;
      environment.etc."resolv.conf".source = "/run/systemd/resolve/stub-resolv.conf";

      services.tailscale.extraUpFlags = [ "--accept-dns=false" ];

      # Handle DNS
      services.resolved = {
        enable = true;
        extraConfig = ''
          DNS=9.9.9.9 149.112.112.112 2620:fe::fe 2620:fe::9
        '';
      };

      systemd.services.tailscale-splitdns = {
        description = "Attach MagicDNS to tailscale0 (systemd-resolved split DNS)";
        after = [ "tailscaled.service" "network-online.target" ];
        wants = [ "network-online.target" ];
        wantedBy = [ "multi-user.target" ];
        partOf = [ "tailscaled.service" ];
        path = [ pkgs.systemd ];
        script = ''
          # Route *.ts.net via MagicDNS on the tailnet
          resolvectl dns tailscale0 100.100.100.100
          resolvectl domain tailscale0 "~.aegean-interval.ts.net"
        '';
        serviceConfig = {
          Type = "oneshot";
          Restart = "on-failure";
        };
      };
    })
  ];
}
