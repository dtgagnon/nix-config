From 57b8500cc02e14fa9c7ea4d89b44e742b4518522 Mon Sep 17 00:00:00 2001
From: dtgagnon <gagnon.derek@gmail.com>
Date: Mon, 9 Feb 2026 12:11:38 -0500
Subject: [PATCH] feat: add which-key popup for incomplete keybindings

---
 app/aerc.go     |  56 +++++++++++
 app/whichkey.go | 249 ++++++++++++++++++++++++++++++++++++++++++++++++
 config/binds.go |  13 +++
 config/ui.go    |   1 +
 4 files changed, 319 insertions(+)
 create mode 100644 app/whichkey.go

diff --git a/app/aerc.go b/app/aerc.go
index 7388caa..9492a81 100644
--- a/app/aerc.go
+++ b/app/aerc.go
@@ -42,6 +42,7 @@ type Aerc struct {
 	tabs        *ui.Tabs
 	beep        func()
 	dialog      ui.DrawableInteractive
+	whichKey    *WhichKeyPopup
 
 	Crypto crypto.Provider
 }
@@ -202,6 +203,23 @@ func (aerc *Aerc) Draw(ctx *ui.Context) {
 			aerc.dialog.Draw(ctx.Subcontext(4, h/2-2, w-8, 4))
 		}
 	}
+	if aerc.whichKey != nil {
+		w, h := ctx.Width(), ctx.Height()
+		popW := aerc.whichKey.Width()
+		popH := aerc.whichKey.Height()
+		if popW > w-2 {
+			popW = w - 2
+		}
+		if popH > h-2 {
+			popH = h - 2
+		}
+		x := (w - popW) / 2
+		y := h - popH - 1 // position above the status bar
+		if y < 0 {
+			y = 0
+		}
+		aerc.whichKey.Draw(ctx.Subcontext(x, y, popW, popH))
+	}
 }
 
 func (aerc *Aerc) HumanReadableBindings() []string {
@@ -290,6 +308,7 @@ func (aerc *Aerc) getBindings() *config.KeyBindings {
 
 func (aerc *Aerc) simulate(strokes []config.KeyStroke) {
 	aerc.pendingKeys = []config.KeyStroke{}
+	aerc.whichKey = nil
 	bindings := aerc.getBindings()
 	complete := aerc.SelectedAccountUiConfig().CompletionMinChars != config.MANUAL_COMPLETE
 	aerc.simulating += 1
@@ -336,6 +355,15 @@ func (aerc *Aerc) Event(event vaxis.Event) bool {
 		}
 	}
 
+	// Dismiss which-key popup on any key press, but do NOT consume the
+	// event so that normal binding resolution still processes it.
+	if aerc.whichKey != nil {
+		if _, ok := event.(vaxis.Key); ok {
+			aerc.whichKey = nil
+			ui.Invalidate()
+		}
+	}
+
 	if aerc.dialog != nil {
 		return aerc.dialog.Event(event)
 	}
@@ -402,12 +430,40 @@ func (aerc *Aerc) Event(event vaxis.Event) bool {
 				aerc.BeginExCommand("")
 				return true
 			}
+			if aerc.simulating == 0 &&
+				aerc.SelectedAccountUiConfig().WhichKey &&
+				event.Matches(bindings.WhichKeyKey.Key, bindings.WhichKeyKey.Modifiers) {
+				var globals *config.KeyBindings
+				if bindings.Globals && config.Binds.Global != nil {
+					globals = config.Binds.Global
+				}
+				wk := NewWhichKeyPopup(
+					nil, bindings, globals,
+				)
+				if !wk.EmptyEntries() {
+					aerc.whichKey = wk
+				}
+				return true
+			}
 			interactive, ok := aerc.SelectedTabContent().(ui.Interactive)
 			if ok {
 				return interactive.Event(event)
 			}
 			return false
 		}
+		if aerc.simulating == 0 &&
+			aerc.SelectedAccountUiConfig().WhichKey {
+			var globals *config.KeyBindings
+			if bindings.Globals && config.Binds.Global != nil {
+				globals = config.Binds.Global
+			}
+			wk := NewWhichKeyPopup(
+				aerc.pendingKeys, bindings, globals,
+			)
+			if !wk.EmptyEntries() {
+				aerc.whichKey = wk
+			}
+		}
 	case vaxis.Mouse:
 		aerc.grid.MouseEvent(event.Col, event.Row, event)
 		return true
diff --git a/app/whichkey.go b/app/whichkey.go
new file mode 100644
index 0000000..002a586
--- /dev/null
+++ b/app/whichkey.go
@@ -0,0 +1,249 @@
+package app
+
+import (
+	"fmt"
+	"sort"
+
+	"git.sr.ht/~rjarry/aerc/config"
+	"git.sr.ht/~rjarry/aerc/lib/ui"
+)
+
+type WhichKeyPopup struct {
+	entries []whichKeyEntry
+	title   string
+	width   int
+	height  int
+	columns int
+	colW    int
+	rows    int
+}
+
+type whichKeyEntry struct {
+	suffix     string
+	annotation string
+}
+
+// NewWhichKeyPopup creates a popup showing available keybindings that match
+// the given prefix. It searches both the context-specific bindings and global
+// bindings (if enabled).
+func NewWhichKeyPopup(
+	prefix []config.KeyStroke,
+	bindings *config.KeyBindings,
+	globals *config.KeyBindings,
+) *WhichKeyPopup {
+	var entries []whichKeyEntry
+	seen := make(map[string]bool)
+
+	collect := func(bs []*config.Binding, tag string) {
+		for _, b := range bs {
+			if len(prefix) > 0 {
+				if len(b.Input) <= len(prefix) {
+					continue
+				}
+				match := true
+				for i, ks := range prefix {
+					if ks != b.Input[i] {
+						match = false
+						break
+					}
+				}
+				if !match {
+					continue
+				}
+			}
+			suffix := config.FormatKeyStrokes(b.Input[len(prefix):])
+			if seen[suffix] {
+				continue
+			}
+			seen[suffix] = true
+
+			ann := b.Annotation
+			if ann == "" {
+				ann = config.FormatKeyStrokes(b.Output)
+			}
+			if tag != "" {
+				ann += " " + tag
+			}
+			entries = append(entries, whichKeyEntry{
+				suffix:     suffix,
+				annotation: ann,
+			})
+		}
+	}
+
+	collect(bindings.Bindings, "")
+	if globals != nil {
+		collect(globals.Bindings, "(global)")
+	}
+
+	sort.Slice(entries, func(i, j int) bool {
+		return entries[i].suffix < entries[j].suffix
+	})
+
+	// Calculate the width of a single entry column:
+	// key + " " + dimSep + " " + annotation
+	maxKeyWidth := 0
+	maxAnnWidth := 0
+	for _, e := range entries {
+		if len(e.suffix) > maxKeyWidth {
+			maxKeyWidth = len(e.suffix)
+		}
+		if len(e.annotation) > maxAnnWidth {
+			maxAnnWidth = len(e.annotation)
+		}
+	}
+
+	var titleStr string
+	if len(prefix) > 0 {
+		titleStr = fmt.Sprintf(" %s... ", config.FormatKeyStrokes(prefix))
+	} else {
+		titleStr = " Keybindings "
+	}
+
+	// Single column entry width: padding(1) + key + gap(1) + sep(1) + gap(1) + ann + padding(1)
+	colW := 1 + maxKeyWidth + 1 + 1 + 1 + maxAnnWidth + 1
+
+	// Determine column count based on entry count
+	maxRows := 16
+	columns := 1
+	rows := len(entries)
+	if rows > maxRows {
+		columns = (rows + maxRows - 1) / maxRows
+		if columns > 3 {
+			columns = 3
+		}
+		rows = (len(entries) + columns - 1) / columns
+	}
+
+	// Total width: columns * colW + (columns-1) separator + 2 borders
+	width := columns*colW + (columns-1) + 2
+	if len(titleStr)+2 > width {
+		width = len(titleStr) + 2
+	}
+	if width < 20 {
+		width = 20
+	}
+
+	// Height: title(1) + rows + bottom border(1)
+	height := 1 + rows + 1
+
+	return &WhichKeyPopup{
+		entries: entries,
+		title:   titleStr,
+		width:   width,
+		height:  height,
+		columns: columns,
+		colW:    colW,
+		rows:    rows,
+	}
+}
+
+func (wk *WhichKeyPopup) Width() int {
+	return wk.width
+}
+
+func (wk *WhichKeyPopup) Height() int {
+	return wk.height
+}
+
+func (wk *WhichKeyPopup) Draw(ctx *ui.Context) {
+	w, h := ctx.Width(), ctx.Height()
+	if w <= 2 || h <= 2 {
+		return
+	}
+
+	uiCfg := SelectedAccountUiConfig()
+	defaultStyle := uiCfg.GetStyle(config.STYLE_DEFAULT)
+	titleStyle := uiCfg.GetStyle(config.STYLE_TITLE)
+	borderStyle := uiCfg.GetStyle(config.STYLE_BORDER)
+	keyStyle := uiCfg.GetStyle(config.STYLE_SELECTOR_FOCUSED)
+	sepStyle := uiCfg.GetStyle(config.STYLE_COMPLETION_GUTTER)
+
+	borderV := uiCfg.BorderCharVertical
+	borderH := uiCfg.BorderCharHorizontal
+
+	// Fill background
+	ctx.Fill(0, 0, w, h, ' ', defaultStyle)
+
+	// -- Title bar (full-width filled row) --
+	ctx.Fill(0, 0, w, 1, ' ', titleStyle)
+	titleX := (w - len(wk.title)) / 2
+	if titleX < 0 {
+		titleX = 0
+	}
+	ctx.Printf(titleX, 0, titleStyle, "%s", wk.title)
+
+	// -- Bottom border --
+	for x := 0; x < w; x++ {
+		ctx.SetCell(x, h-1, borderH, borderStyle)
+	}
+
+	// -- Left/right borders on content rows --
+	for y := 1; y < h-1; y++ {
+		ctx.SetCell(0, y, borderV, borderStyle)
+		ctx.SetCell(w-1, y, borderV, borderStyle)
+	}
+
+	// -- Bottom corners --
+	ctx.SetCell(0, h-1, '╰', borderStyle)
+	ctx.SetCell(w-1, h-1, '╯', borderStyle)
+
+	// Calculate max key width from entries for alignment
+	maxKeyWidth := 0
+	for _, e := range wk.entries {
+		if len(e.suffix) > maxKeyWidth {
+			maxKeyWidth = len(e.suffix)
+		}
+	}
+
+	// -- Draw entries in columns --
+	for i, e := range wk.entries {
+		col := i / wk.rows
+		row := i % wk.rows
+		y := row + 1 // +1 for title bar
+		if y >= h-1 {
+			break
+		}
+
+		// x offset: border(1) + col * (colW + separator(1))
+		xBase := 1 + col*(wk.colW+1)
+
+		// Draw column separator line if not first column
+		if col > 0 {
+			sepX := xBase - 1
+			if sepX > 0 && sepX < w-1 {
+				ctx.SetCell(sepX, y, '│', sepStyle)
+			}
+		}
+
+		// Key (highlighted with accent style)
+		keyStr := fmt.Sprintf(" %-*s", maxKeyWidth, e.suffix)
+		ctx.Printf(xBase, y, keyStyle, "%s", keyStr)
+
+		// Separator (dimmed)
+		sepStr := " · "
+		ctx.Printf(xBase+1+maxKeyWidth, y, sepStyle, "%s", sepStr)
+
+		// Annotation
+		annX := xBase + 1 + maxKeyWidth + 3
+		remaining := w - 1 - annX // leave room for right border
+		ann := e.annotation
+		if remaining > 0 && len(ann) > remaining {
+			if remaining > 1 {
+				ann = ann[:remaining-1] + "…"
+			} else {
+				ann = "…"
+			}
+		}
+		ctx.Printf(annX, y, defaultStyle, "%s", ann)
+	}
+}
+
+func (wk *WhichKeyPopup) Invalidate() {
+	ui.Invalidate()
+}
+
+// EmptyEntries returns true if there are no matching bindings to show
+func (wk *WhichKeyPopup) EmptyEntries() bool {
+	return len(wk.entries) == 0
+}
diff --git a/config/binds.go b/config/binds.go
index 3b9510c..60d6247 100644
--- a/config/binds.go
+++ b/config/binds.go
@@ -62,6 +62,8 @@ type KeyBindings struct {
 	ExKey KeyStroke
 	// Which key triggers completion (default is <tab>)
 	CompleteKey KeyStroke
+	// Which key opens the which-key popup (default is ?)
+	WhichKeyKey KeyStroke
 
 	// private
 	contextualBinds  []*BindingConfigContext
@@ -204,6 +206,15 @@ func LoadBindingSection(sec *ini.Section) (*KeyBindings, error) {
 				return nil, errors.New("Invalid binding")
 			}
 			bindings.CompleteKey = strokes[0]
+		case "$whichkey":
+			strokes, err := ParseKeyStrokes(value)
+			if err != nil {
+				return nil, err
+			}
+			if len(strokes) != 1 {
+				return nil, errors.New("Invalid binding")
+			}
+			bindings.WhichKeyKey = strokes[0]
 		default:
 			annotation = strings.TrimSpace(annotation)
 			binding, err := ParseBinding(key, value, annotation)
@@ -299,6 +310,7 @@ func NewKeyBindings() *KeyBindings {
 	return &KeyBindings{
 		ExKey:            KeyStroke{0, ':'},
 		CompleteKey:      KeyStroke{0, vaxis.KeyTab},
+		WhichKeyKey:      KeyStroke{0, '?'},
 		Globals:          true,
 		contextualCache:  make(map[bindsContextKey]*KeyBindings),
 		contextualCounts: make(map[bindsContextType]int),
@@ -363,6 +375,7 @@ func MergeBindings(bindings ...*KeyBindings) *KeyBindings {
 	merged.Bindings = filterAndCleanBindings(merged.Bindings)
 	merged.ExKey = bindings[0].ExKey
 	merged.CompleteKey = bindings[0].CompleteKey
+	merged.WhichKeyKey = bindings[0].WhichKeyKey
 	merged.Globals = bindings[0].Globals
 	for _, b := range bindings {
 		merged.contextualBinds = append(merged.contextualBinds, b.contextualBinds...)
diff --git a/config/ui.go b/config/ui.go
index cf13191..b423116 100644
--- a/config/ui.go
+++ b/config/ui.go
@@ -48,6 +48,7 @@ type UIConfig struct {
 	ClientThreadsDelay            time.Duration `ini:"client-threads-delay" default:"50ms"`
 	ThreadContext                 bool          `ini:"show-thread-context"`
 	FuzzyComplete                 bool          `ini:"fuzzy-complete"`
+	WhichKey                      bool          `ini:"which-key"`
 	NewMessageBell                bool          `ini:"new-message-bell" default:"true"`
 	Spinner                       string        `ini:"spinner" default:"[..]    , [..]   ,  [..]  ,   [..] ,    [..],   [..] ,  [..]  , [..]   "`
 	SpinnerDelimiter              string        `ini:"spinner-delimiter" default:","`
-- 
2.52.0

